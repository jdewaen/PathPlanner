
\documentclass[12pt]{article}
%	options include 12pt or 11pt or 10pt
%	classes include article, report, book, letter, thesis

\title{Two-Phase Scalable Mixed-Integer Path Planning for UAVs}
\usepackage{amsmath}
\usepackage{relsize}
\usepackage{mathtools}
\author{Jorik De Waen}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}
As a consequence of ever-increasing automation in our daily lives, more and more machines have to interact with and unpredictable environment and other actors within that environment. One of the sectors that seems like it will change dramatically in the near future is the transportation industry. Autonomous cars are actually starting to appear on public roads, autonomous truck convoys are being tested and large retail distributors like Amazon are investing heavily into delivering order by drones instead of courier. While these developments look promising, there are still many challenges that prevent these systems from being widely deployed.
\par
One such challenge, which is especially important for areal vehicles, is path planning. Even though most modern quadrocopters are capable of flying by themselves, they are unable to generate a flight path that will get them to their destination reliably. Classic graph-based shortest path algorithms like Dijkstra's algorithm its many variants fail to take momentum and other factors into account. Mixed Integer Linear Programming (MILP) is one approach that shows promising results, however it is currently severely limited by computational complexity.



\newpage
\subsection{Motivation and Goal for the Thesis}
One of the main advantages of using a constraint optimization approach like MILP is that they are extremely extendable by design. A system based on this can be deployed in many different scenarios with different goals and constraints without the need for significant changes to the algorithms that drive it. The solvers that construct the final path are general solvers which take constraints and a target function as input. This input can be generated by end users in the field to match their specific requirements, making the software controlling the drones as flexible as the hardware.
\par
That flexibility is also the main limitation of using constraint optimization. The solvers are general purpose, which make them very slow compared to more direct approaches. They need to be carefully guided solve all but the most basic scenarios in a reasonable amount of time. While there have been some good results on small scales, I could not find any attempts at planning paths on the order of kilometers or more. Practical use cases involving drones often involve several minutes of flight and can cover several kilometers, so a path planner must be able to work at such a scale. This is the main goal of this thesis: To demonstrate how a MILP approach can be scaled to scenarios with a much larger scope, while preserving the advantages that make it interesting.
\subsection{Structure of the Thesis}
Section \ref{subsec:previous} summarizes the previous work that has been done in the field.
The previous work in the field shows a common design to modeling the path planning problem as a MILP problem. This design forms the core of the approach in this thesis as well. Section \ref{section:modeling} shows the implementation of this common design and explores the critical limitations to this approach.
\par
Section \ref{section:segment} proposes a solution to these limitation. By finding a rough initial path, the planning problem can be split into smaller segments. Solving these segments on their own is significantly easier and can still enforce all the constraints. This approach is much faster than previous techniques, but at the cost of no longer finding the global optimum.
\par
During the development of this algorithm, finding and solving bugs and other unwanted behavior proved to be a significant challenge. A visualization tool was developed to make it easier to see how the algorithm operates. Section \ref{section:visual} goes into detail of how nearly every variable in the MILP problem was visualized and how this information can be interpreted.
\par
To demonstrate the flexibility of the approach, section \ref{section:extension} showcases some possible extensions that can be added with relative ease. Some of these have been fully implemented to look at the impact on the solution. This section should demonstrate that the path planner discussed in this thesis is a modular strategy built out of several different algorithms. The specific algorithms discussed are just one way of doing things, and can be easily swapped out for other, more advanced, algorithms. 
\par
Section \ref{section:result} analyzes the performance of the path planner in several different scenarios. It also looks at how the extensions which have been implemented affect the both the performance and quality of the planner.
Finally, section \ref{section:summary} summarizes the main observations in this thesis and concludes whether or not the goals have been realized.

\subsection{Context}
\label{subsec:previous}
Mixed integer linear programming is and extension of linear programming. In a linear programming problem, there is a single (linear) target function which needs to be minimized or maximized by the solver. A problem typically also contains a number linear inequalities which constrain the values of the variables in the target function.
\begin{figure}[placement specifier]
EXAMPLE LINEAR PROBLEM HERE
\end{figure}
When all the variables are real, problems like this can be solved in polynomial time. However, only convex search spaces can be modeled this way. By adding obstacles to the world the drone has to navigate, the search space becomes non-convex. To express non-convex search spaces, integer variables are required\cite{Schouwenaars2001}. A linear problem with integer variables is called a mixed integer linear problem. These integers make it possible to model logical expressions, which in turn enable approximations of non-linear function to be used.
\par
fixed horizon vs receding horizon \cite{Bellingham2002}
\par
differential flatness \cite{Fliess1995a} \cite{Hao2005} \cite{Cowling2007} \cite{Mellinger2011}
\par
curve approaches \cite{Deits2015} \cite{Flores2007}


OBSERVATIES

voorbeeld van benchmark probleem met/zonder segmentatie

probleem met non-convexe zoekruimte, nood voor integer variabelen

oplossing: segmentatie


\section{Modeling Path Planning as a MILP problem}
\label{section:modeling}
The path planning problem can be represented with discrete timesteps with a set of state variables for each epoch. The amount of timesteps determines the maximum amount of time the vehicle has in solution space to reach its goal. The actual movement of the vehicle is modeled by calculating the accelleration, velocity and position at each timestep based on the throttle (in each axis) and state variables from the previous time step.

\begin{figure}[h]
\begin{math}
time_0 = 0 \\
time_{t+1} = time_{t} + \Delta t,  \quad 0 \leq t < N \\ \\
\boldsymbol{pos}_0 = \boldsymbol{pos}_{start} \\
\boldsymbol{pos}_{t+1} = \boldsymbol{pos}_{t} + \Delta t * \boldsymbol{vel}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{vel}_0 =\boldsymbol{vel}_{start} \\
\boldsymbol{vel}_{t+1} =\boldsymbol{vel}_{t} + \Delta t * \boldsymbol{acc}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{acc}_{t} = \boldsymbol{throttle}_{t} * \boldsymbol{acc}_{max}  \quad 0 \leq t \leq N \\
\end{math}
\end{figure}

The problem also needs a goal function to optimize. In this model, the goal is to minimize the time before a goal position is reached. Optionally, there is also a goal velocity that needs to be matched when the vehicle reaches the goal. Reaching the goal constraints causes a state transition from not being finished to being finished. Modeling state transitions directly can be error-prone, so Lamport's\cite{Lamport1989} state transition axiom method was used. In this simple model it is still possible to model the state transition directly, but the goal of the thesis is to provide a flexible and extensible approach.


\begin{figure}[h]
\begin{math}
minimize \quad N - \mathlarger{\sum}_{t=0}^{t \leq N} fin_t \\
fin_0 = 1 \\ 
fin_{t+1} = fin_t \vee cfin_{t+1},  \quad 0 \leq t < N \\ \\
cfin_{pos,t} =  \mathlarger{\mathlarger{\bigwedge_{i = 0}^{i < Dim(\boldsymbol{pos}_t)}}} |pos_{t,i} - pos_{goal, i}| < pos_{tol},  \quad 0 \leq t \leq N \\ \\ \\
cfin_{vel,t} = 
\begin{cases*}
\mathlarger{\bigwedge_{i = 0}^{i < Dim(\boldsymbol{vel}_t)}} |vel_{t,i} -vel_{goal, i}| < vel_{tol}& if $\boldsymbol{vel}_{goal}$ exists, $0 \leq t \leq N$  \\
true & otherwise, $0 \leq t \leq N$ 
\end{cases*} \\ \\ \\
cfin_t =  cfin_{pos,t} \bigwedge cfin_{vel,t} \quad 0 \leq t \leq N
\end{math}
\end{figure}

Vehicles have a maximum velocity they can achieve. Calculating the velocity of the vehicle means applying Pythagoras' theorem on the axis of the velocity vector. This is not possible using only linear equations. However, it can be approximated to an arbitrary degree using multiple linear constraints. The components of the velocity vector can be positive or negative, but only the absolute value matters for the actual velocity. Because other constraints may also need the absolute velocity, it is calculated even though the absolute value function is not convex and will lead to a small performance penalty.
\begin{figure}[h]
ABS \\
MAXSPEED
\end{figure}
One of the constraints that can use this absolute velocity is a minimum velocity constraint. some vehicles, like fixed-wing aircraft, always need to travel above a certain velocity. While the focus for the thesis is on multi rotor vehicles, this is another demonstration of the flexibility of this approach. More constraints are needed to properly model a fixed-wing aircraft, but this provides a sensible first degree approximation. Modeling a minimum velocity also leads to a non-convex search space. Using the absolute velocity reduces the amount of integer variables needed to model the minimum velocity to the same precision by three quarters in 2D and seven eights in 3D.
\begin{figure}[h]
MINSPEED
\end{figure}

The most challenging part of the problem is modeling obstacles. Any obstacle between the vehicle and its goal will inherently make the search space non-convex. Because of this, integer variables are needed to model obstacles. The most common way to do this is to use the ``Big M'' method to model a polygon. The size of the vehicle needs to be taken into account. Assuming the polygon is convex and the vertices of the polygon are listed in counter-clockwise order, the following constraints model an obstacle:

\begin{figure}[h]
OBSTACLE CONSTRAINTS \\
\end{figure}

Because obstacles make the problem non-convex and thus require integer constraints to model, the execution time scales very poorly with the amount of obstacles. This can be mitigated by only modeling a certain amount of obstacles relatively close to the vehicle, while limiting the vehicle to a convex region which does not overlap any of the ignored obstacles. Modeling this convex allowed region is very similar to modeling the obstacles, except that this time no integer variables are needed.

\begin{figure}[h]
ACTIVE REGION\\
\end{figure}

\section{Segmentation of the MILP problem}
\label{section:segment}

Short paths can be solved directly, but longer paths with a large amount of obstacles nearby take an extremely long time to solve. A solution to this problem is to divide the path into smaller segments. Solving the smaller segments is proportionally disproportionately easier than solving the full path, but at the cost of optimality and stability.
\\
\subsection{Finding the initial path}
The first issue is that because the goal cannot be reached immediately, the goal function needs to change.  \\
One option is to simply get as close as possible to the goal during each segment. Because the distance that can be traveled during a segment is limited, the amount of obstacles that need to be modeled is also limited. This works well when the world is very open with little obstacles. However, this greedy approach is prone to getting stuck in dead ends in more dense worlds like cities.
\\
The second option is finding a complete path using a method that's easier to compute. An algorithm like A* can be used to find a rough estimation for the path. This A* path is the shortest path, but does not take constraints or the characteristics of the vehicle into account. A very curvy direct path may be the shortest, but a detour which is mostly straight and allows for higher speeds may actually be faster. 
\\
It is possible to use more advanced algorithms that model more of the constraints. This will significantly improve the speed and quality of the constraint optimization step, but it will also come at a performance cost. A balance needs to be found between the preprocessing step and the constraint optimization step. The preprocessing step needs to do just enough so the optimization step can be solved in an acceptable amount of time. 
\\
I have decided to use Theta*. This is a variant  of A* that allows for paths at arbitrary angles instead of multiples of 45 degrees. The main reason for this is that it eliminates the ``zig zags'' that A* produces. This makes the next step of the preprocessing much easier.\\
\subsection{Detecting corner events}
With an initial path generated, the next problem is dividing it into segments. Dividing the path into equal parts presents problems, because when solving each segment, the solver has no knowledge of what will happen in the next segment. This is especially problematic when the vehicle needs to make a tight corner. If the last segment ends right before the corner, it may not be possible to avoid a collision.\\
In Euclidian geometry, the shortest path between two points is always a straight line. When polygonal obstacles are introduced between those points, the shortest path will be composed of straight lines with turns at one or more vertices of the obstacles. The obstacle that causes the turn will always be on the inside of the corner. This shows why corners are important for another reason: They make the search space non-convex. For obstacles on the outside of the corner it is possible to constrain the search space so it is still convex, but this is not possible for obstacles on the inside.\\
Because of these reasons, isolating the corners from the rest of the path is advantageous. With enough buffer before the corner, the vehicle is much more likely to be able to navigate the corner successfully. It also means that the computationally expensive parts of the path are as small as possible while still containing enough information for fast navigation through the corner.
\\
The reason for using Theta* becomes clear now. Every single node in the path generated by the algorithm is guaranteed to be either the start, finish or near a corner. A corner can have more than one node, so nodes which turn in the same direction and are close to each other are merged into a single corner event. A corner event is also generated for nodes which are alone.
\subsection{Generating path segments}
These corner events are in turn grown outwards to cover the approach and departure from the corner. How much depends on the maximum acceleration of the vehicle. As a rule of thumb: If the vehicle can come to a complete stop from its maximum speed before the corner, it can also successfully navigate that corner. When corners appear in quick succession, their expanded regions may overlap. In that case, the middle between those corners is chosen. Long, straight sections are also divided into smaller path segments.\\

FIND IMPORTANT OBSTACLES FROM CONVEX HULL OF PATH SEGMENT\\
GENETIC ALGORITHM FOR ALLOWED AREA\\

\bibliographystyle{plain}
\bibliography{../papers/bib.bib}
\end{document}