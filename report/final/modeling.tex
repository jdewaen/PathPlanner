\section{Modeling Path Planning as a MILP problem}
\subsection{Introduction}
TODO: REWRITE
MILP is a form of mathematical programming, form of declarative programming. contrast with imperative programming: say what the solution looks like instead of how to get there. Mathematical programming: subset of declarative programming where problem is defined as mathematical problem. Solver computes result.

\\
Big advantages: \\
- dont need to say how it is done, focus is on precisely modeling problem.\\
- flexible: can easily change rules: make problem more restrictive or relaxed, change the goal, etc ``just works''\\
- can be really fast thanks to work on solvers\\
\\
disadvatages:\\
- no free lunch (find reference): for anything more than very basic cases, solver cannot guarantee that a solution will be found any faster than random search\\
	--> cant rely on just the solver doing the work, problem needs to be stated in a way that guides solver in the right direction
	--> even when careful, as problem becomes more complex, solvers struggle
-  hard to understand: solver finds solution or not.
	-->Solution is optimal, but if it is not as expected it does not give any information why.
	-->when no solution: can show which constraint failed, but problem is not necessarily there. complex interplay between constraints is extremely hard to debug

\\


\subsection{Terminology}
TODO: FILL OUT
variable
constraint
solution space
feasible region
solver (cplex)
convex

\subsection{Importance of integers and convexity}
TODO: REWRITE
linear programming one of the most simple forms of mathematical programming. Only linear functions allowed, all variables have a real domain. If feasible region exists: inherently convex. When a problem is convex, typically efficient solvers can be written (TODO: find source). This is the case for LP. LP problems can be solved reliably and quickly.
\\
Problem: only real variables is very limiting. Logical operators are impossible to model. Result is that not every problem can be modeled without integers. Adding integers seems like a minor change, but it no longer guarantees that the feasible region is convex. When the problem is no longer convex, it becomes intractible. An intractible problem is a problem for which we do not have a strategy that will on average find the solution faster than random guessing.
\\
Path planning when obstacles are present inherently needs integer variables and thus is an intractible problem. The goal of this thesis is to make this approach to path planning scalable. This will rely on two concepts://
- The solvers are on average not faster than random, but that's the average of all problems. We are only concerned with a very specific kind of problem. By being aware of how the solver works and simply experimenting with different representations, the problem can be solved much faster\\
- We can cheat. The problem can be greatly simplified and approximated. This means that the solution is no longer guaranteed to be optimal, but as long as it is good enough this is not a problem.\\



\label{section:modeling}
The path planning problem can be represented with discrete timesteps with a set of state variables for each epoch. The amount of timesteps determines the maximum amount of time the vehicle has in solution space to reach its goal. The actual movement of the vehicle is modeled by calculating the accelleration, velocity and position at each timestep based on the throttle (in each axis) and state variables from the previous time step.

\begin{figure}[h]
\begin{math}
time_0 = 0 \\
time_{t+1} = time_{t} + \Delta t,  \quad 0 \leq t < N \\ \\
\boldsymbol{pos}_0 = \boldsymbol{pos}_{start} \\
\boldsymbol{pos}_{t+1} = \boldsymbol{pos}_{t} + \Delta t * \boldsymbol{vel}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{vel}_0 =\boldsymbol{vel}_{start} \\
\boldsymbol{vel}_{t+1} =\boldsymbol{vel}_{t} + \Delta t * \boldsymbol{acc}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{acc}_{t} = \boldsymbol{throttle}_{t} * \boldsymbol{acc}_{max}  \quad 0 \leq t \leq N \\
\end{math}
\end{figure}

The problem also needs a goal function to optimize. In this model, the goal is to minimize the time before a goal position is reached. Optionally, there is also a goal velocity that needs to be matched when the vehicle reaches the goal. Reaching the goal constraints causes a state transition from not being finished to being finished. Modeling state transitions directly can be error-prone, so Lamport's\cite{Lamport1989} state transition axiom method was used. In this simple model it is still possible to model the state transition directly, but the goal of the thesis is to provide a flexible and extensible approach.


\begin{figure}[h]
\begin{math}
minimize \quad N - \mathlarger{\sum}_{t=0}^{t \leq N} fin_t \\
fin_0 = 1 \\ 
fin_{t+1} = fin_t \vee cfin_{t+1},  \quad 0 \leq t < N \\ \\
cfin_{pos,t} =  \mathlarger{\mathlarger{\bigwedge_{i = 0}^{i < Dim(\boldsymbol{pos}_t)}}} |pos_{t,i} - pos_{goal, i}| < pos_{tol},  \quad 0 \leq t \leq N \\ \\ \\
cfin_{vel,t} = 
\begin{cases*}
\mathlarger{\bigwedge_{i = 0}^{i < Dim(\boldsymbol{vel}_t)}} |vel_{t,i} -vel_{goal, i}| < vel_{tol}& if $\boldsymbol{vel}_{goal}$ exists, $0 \leq t \leq N$  \\
true & otherwise, $0 \leq t \leq N$ 
\end{cases*} \\ \\ \\
cfin_t =  cfin_{pos,t} \bigwedge cfin_{vel,t} \quad 0 \leq t \leq N
\end{math}
\end{figure}

Vehicles have a maximum velocity they can achieve. Calculating the velocity of the vehicle means applying Pythagoras' theorem on the axis of the velocity vector. This is not possible using only linear equations. However, it can be approximated to an arbitrary degree using multiple linear constraints. The components of the velocity vector can be positive or negative, but only the absolute value matters for the actual velocity. 
\begin{figure}[h]
ABS \\
MAXSPEED
\end{figure}

The most challenging part of the problem is modeling obstacles. Any obstacle between the vehicle and its goal will inherently make the search space non-convex. Because of this, integer variables are needed to model obstacles. The most common way to do this is to use the ``Big M'' method to model a polygon. The size of the vehicle needs to be taken into account. Assuming the polygon is convex and the vertices of the polygon are listed in counter-clockwise order, the following constraints model an obstacle:

\begin{figure}[h]
OBSTACLE CONSTRAINTS \\
\end{figure}

Because obstacles make the problem non-convex and thus require integer constraints to model, the execution time scales very poorly with the amount of obstacles. This can be mitigated by only modeling a certain amount of obstacles relatively close to the vehicle, while limiting the vehicle to a convex region which does not overlap any of the ignored obstacles. Modeling this convex allowed region is very similar to modeling the obstacles, except that this time no integer variables are needed.

\begin{figure}[h]
ACTIVE REGION\\
\end{figure}