\section{Segmentation of the MILP problem}
\label{section:segment}
This section proposes a preprocessing algorithm to improve the scalability of MILP trajectory planning.\\ 
Assuming Hypothesis \ref{hyp:nonconvex} is true, a high degree of non-convexity around the trajectory causes slow solve times. There are two issues with this. The first issue is that the trajectory is the solution for the problem. If the solution is known, the problem does not need to be solved anymore. The second issue is that even if the optimal trajectory is known, the degree of non-convexity around that trajectory cannot be reduced by much since it already is the optimal trajectory. For instance, the Up/Down scenario in Figure \ref{fig:benchmarks-convex} cannot be made more convex without changing the original problem.\\
However, these issues can be resolved by relaxing the requirement of finding the optimal trajectory. The UAV operates in the real world, so a "good enough" trajectory will do. The MILP trajectory planning problem can be divided into many sub-problems, each of which solve a small part of the trajectory. By dividing the MILP problem into smaller sub-problems, the guarantee of optimality no longer holds. The optimal trajectory for each sub-problem will be found, but the combined trajectories may not be the optimal solution for the original problem. However, the degree of non-convexity can be limited in each sub-problem, which improves the scalability. \\
The non-convexity of a trajectory planning problem manifests itself as turns in the trajectory. Because of this, limiting the amount of turns in each sub-trajectory also limits the degree of non-convexity around the sub-trajectory. Limiting the amount of turns in each sub-problem is one of the goals for the preprocessing algorithm.\\
Before the algorithm can take turns into account when building the sub-problems, the turns in the trajectory need to be known. This trajectory is not known in advance, but this is not required. A faster path planning algorithm can be used to find a path from the start to the goal position. Unlike a trajectory, a path is not time-dependent and does not take the dynamics of the UAV into account. These simplifications make path planning algorithms typically much faster than trajectory planning algorithms. Despite the limitations of the path, the turns in the path do correspond to turns in the trajectory. However, it also means the trajectory may not be the fastest trajectory. Once again, optimality is sacrificed. \\

%\subsection{Introduction}
%The MILP model described in section \ref{section:modelingbasic} is sufficient to solve the trajectory planning problem for short flights with few obstacles. However, it scales poorly when the duration of the flight or the amount of obstacles is increased. Mixed-Integer programming belongs to the ``NP-Complete'' class of problems \cite{DBLP:conf/coco/Karp72}. This is a class of problems which is considered very hard to solve. As the amount of integer variables grows, the time needed to solve the problem increases exponentially. An integer variable is needed for every edge of every polygon, for every time step. By reducing both the amount of time steps needed and obstacles that need to be modeled, the execution time can be reduced dramatically. \\
%The key insight that allows my algorithm to scale well beyond what's usually possible is that the path trajectory not need to be solved all at once. If the trajectory planning problem can be split into many different subproblems, each subproblem becomes easier to solve. The solution for each subproblem is a small part of the final trajectory. By solving theses subproblems sequentially, the final trajectory can gradually be constructed. \\
%While diving the problem into subproblems does make things much easier to solve, it also has an important down side: Finding the fastest trajectory can no longer be guaranteed. Smaller subproblems make it easier to find a solution, but fundamentally the problem of finding the optimal trajectory is still just as hard. The necessary trade-off for better performance is that the optimal trajectory will likely not be found. Luckily, the optimal trajectory is often not required in navigation. A reasonably good trajectory will do.
%
%\subsubsection{The importance of convexity}
%While the worst case time needed to solve a MILP problem increases exponentially with the amount of integer variables, this is not the most useful way to measure the difficulty of a problem. Modern solvers are heavily optimized and are able to solve certain problems with many integer variables much faster than others. The key difference is the convexity of the solution space. Just like a circle is the solution space for ``all points a certain distance away from the center point'', the constraints used to model the trajectory planning problem form some geometric shape with a dimension for every variable. \\
%When only linear constraints with real values are used, the solution space will always be convex. It is this convexity that makes a standard linear program easy to solve. When integer variables are introduced, it is possible to construct solution spaces which are not convex. As the solution space becomes less and less convex, the problem becomes harder to solve. Integer variables can be seen as a tool which allows non-convex solution spaces to be modeled. When trying to improve the difficulty of a problem, the actual goal is making the problem more convex (or smaller, which always helps). Reducing the amount of integer variables is only a side effect. \\
%This insight is critical when determining how to divide the trajectory problem into smaller subproblems, and which obstacles are important for each subproblem.
\subsubsection{General Algorithm Outline}
\begin{algorithm}
\caption{General outline}
\label{alg:outline}
\begin{algorithmic}[1]
\State $T \leftarrow \{\}$ \Comment{The list of solved subtrajectories}
\State $path \leftarrow$ \Call{Theta*}{$scenario$}
\State $events \leftarrow$ \Call{FindTurnEvents}{$path$}
\State $segments \leftarrow$ \Call{GenSegments}{$path$, $events$}
\ForEach {$segment \in segments$}
\State \Call{UpdateStartState}{$segment$}
\State \Call{GenSafeRegion}{$scenario$, $segment$}
\State \Call{GenSubMILP}{$scenario$, $segment$}
\State $T \leftarrow T \cup \{$ \Call{SolveSubMILP}{} $\}$
\EndFor
\State $result \leftarrow $\Call{MergeTrajectories}{$T$}
\end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:outline} shows the general outline of the algorithm. It consists of two phases. The first phase gathers information about the trajectory planning problem. A Theta* path planning algorithm is used to find an initial path (line 2). From this initial path, turn events are generated (line 3). These turn events mark where the trajectory will have to turn. \\
The seconds stage builds and solves "segments". Each segment represents a single sub-trajectory. The segments contain the information needed to build the corresponding MILP sub-problem, which can in turn be solved by the solver. First, each segment is generated (line 3) from the turns found in the previous step. Before the MILP sub-problem can be generated and solved (line 8-9), a heuristic selects several obstacles to be modeled in the problem. A genetic algorithm generates a safe region which is allowed with those selected obstacles only (line 7). To ensure a seamless transition between two consecutive sub-trajectories, the starting state for the UAV in the MILP current segment is updated to match the final state of the UAV in the previous segment (line 6). Finally, the sub-trajectories are merged together to form the final trajectory (line 11).

%The algorithm I developed consists of two phases.\\
%In the first phase, information is gathered about the trajectory planning problem. The Theta* algorithm is used to construct an initial path from the start to the goal position. Unlike a trajectory, a path is not time-dependent and does not take dynamic properties into account. This makes a path much easier to calculate than a trajectory. While the Theta* path is not suitable to describe the movements of a UAV, it contains useful information about the trajectory we want to calculate. More specifically, the turns in the Theta* path are used to generate path segments. Each path segment contains the information needed to construct a MILP subproblem. \\
%In the second phase, each path segment considered sequentially. First, for all but the first segment,


\subsection{Finding the initial path}
The first step in Algorithm \ref{alg:outline} is finding the Theta* path (line 2). This path will be used to divide the trajectory planning problem into segments. The MILP-problem generated from each of those segments needs an intermediate goal to get the UAV closer to the final goal position. These intermediate goals will be determined by the Theta* path. \\
This path is not only useful to guide the trajectory towards the goal. It is also lets the algorithm determine where the turns will be in the trajectory.

\subsubsection{A*}
Theta* is a variant of the A* path planning algorithm. In A*, the world is represented as a graph. Each possible position is represented as a node, with edges between nodes if one position can be reached from the other. The distance between connected positions is represented as a weight or cost on each edge. \\
Planning a path consists of picking a start and goal position. The A* algorithm will traverse the edges between nodes, keeping track of which edges it traversed to reach a certain node. When the algorithm reaches the goal node, the edges traversed to reach that node are the path from the start node to the goal node. \\
In this case, the world the UAV travels through is a continuous (2D) world. The graph for A* star is generated by overlaying a grid on the world. Nodes are placed at each intersection of the grid, as long as they are not inside obstacles. Each node is also connected to its neighbors by moving horizontally, vertically or diagonally along the grid. Figure \ref{fig:astar-grid} shows an example of this.
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{astar-grid}
\caption{An example of how a grid is used to build the graph for the path finding algorithm. Each point is a node on the graph. If two points are connected by a line, their nodes in the graph also are connected by an edge. Diagonal edges are not shown here for clarity.}
\label{figure:astar-grid}
\end{figure}

\subsubsection{Reason for Theta*}
A* finds the shortest path through the graph. However, this graph is only an approximate representation of the actual continuous world. An A* path will only travel along the edges of the graph. This means that the path can only travel horizontally, vertically and possible diagonally. If the shortest path between two points is at another angle, the A* path will contain zig-zags or detours because it is limited to traveling along the grid. \\
Theta* solves this problem. It is nearly identical to A*, but it allows the path to travel at arbitrary angles. It still traverses the graph using the edges between nodes, but does not restrict the path to only following those edges.

\begin{figure}
\includegraphics[width=0.5\textwidth]{a_theta_star_comp3}
\caption{The red line shows a typical A* path, compared to the path found by Theta*. The gray rectangle is an obstacle.}
\label{figure:thetastarcompare}
\end{figure}


\subsubsection{Theta* implementation}
\begin{algorithm}
\caption{Theta* Implementation}
\label{alg:thetastar}
\begin{algorithmic}[1]
\State $g(v_{start}) \leftarrow 0$
\State $parent(v_{start}) \leftarrow null$
\State $queue \leftarrow \emptyset$
\State $queue$.Insert($v_{start}$, $g(v_{start}) + c(v_{start}, v_{goal})$)
\While{$queue \neq \emptyset$}
	\State $s \leftarrow queue$.Pop()
	\If{$s = s_{goal}$}
		\State return "path found"
	\EndIf
	\ForEach{$s' \in ~ $GenerateNeighbors($s$)}
		
	\EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}
TODO: paraphrased! CITE!!
Algorithm \ref{alg:thetastar} shows how Theta* is implemented. It uses the following elements:
\begin{itemize}
\item the g-value $g(s)$ is the length of the shortest path between the start node and $s$.
\item a function $c(s,s')$ which returns the distance between node $s$ and $s'$.
\item a function $parent(s)$ which returns the node before $s$ in the path. When the parent of a node is $null$, it is either not part of the path or the first node of the path.
\item a priority queue $queue$. This is a queue of nodes to expand next. Each node $s$ is added with a value $x$ using the $queue.$Insert($s$,$x$) method. The $queue$.Pop() method removes and returns the node $s$ with the lowest value $x$.
\item a set $expanded$ which contains all nodes which have already been expanded.
\item a function GenerateNeighbors($s$) which generates and returns the neighbors of node $s$. These are the neighboring positions
\end{itemize}
When the algorithm initializes, the g-value of the start


\subsubsection{Theta* optimizations}
heuristic \\
indexed obstacles \\
possible position: first fuzzy collision, after: LOS check with last point \\
line of sight: first bounding box overlap, only after LOS \\

\subsubsection{Scalability of Theta*}
TODO: REWRITE... KEEP?
Theta* provides the information that makes it possible to make MILP fast, but Theta* in itself is intractable. Why is this not simply moving the issue?\\
Theta* is indeed intractable, but still much better than MILP. Holomomic vs non-holonomic. Concept of navigation mesh as part of map, often used in video games to allow AI to navigate large worlds. Also same concept behind PRM. Only needs to pre precomputed once per map. Can serve as heuristic for Theta*, or completely replace it.


\subsection{Detecting corner events}
With an initial path generated, the next problem is dividing it into segments. Dividing the path into equal parts presents problems, because when solving each segment, the solver has no knowledge of what will happen in the next segment. This is especially problematic when the vehicle needs to make a tight corner. If the last segment ends right before the corner, it may not be possible to avoid a collision. Because of this, corners need to be taken into account when generating the segments. The right image in figure \ref{fig:pre-1-2} shows the transitions between segments as green circles.\\
In Euclidian geometry, the shortest path between two points is always a straight line. When polygonal obstacles are introduced between those points, the shortest path will be composed of straight lines with turns at one or more vertices of the obstacles. The obstacle that causes the turn will always be on the inside of the corner. This shows why corners are important for another reason: They make the search space non-convex. For obstacles on the outside of the corner it is possible to constrain the search space so it is still convex, but this is not possible for obstacles on the inside of a corner.\\
Because of these reasons, isolating the corners from the rest of the path is advantageous. With enough buffer before the corner, the vehicle is much more likely to be able to navigate the corner successfully. It also means that the computationally expensive parts of the path are as small as possible while still containing enough information for fast navigation through the corners.
\\
The reason for using Theta* becomes clear now. Every single node in the path generated by the algorithm is guaranteed to be either the start, goal or near a corner. A corner can have more than one node, so nodes which turn in the same direction and are close to each other are grouped together and considered part of the same corner. For each corner, a corner event is generated.

\subsubsection{Algorithm Implementation}
code \\
parameter tolerance, link to acc distance\\
\subsubsection{Tight Coupling with Theta*}
This algorithm relies on assumptions from Theta*, so if algorithm changes, this will need to be updated.


\begin{figure}[!t]
    \centering
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre1}
    \end{subfigure}
    \hfil
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre2}
    \end{subfigure}
    \caption{The left image shows the results after the Theta* algorithm has executed. The blue shapes are obstacles, while the gray line is the Theta* path. The right image shows the results after the path is segmented. Extra nodes have been added to the Theta* path, as marked by the green circles. These circles depict the transitions between segments.}\label{fig:pre-1-2}
\end{figure}

\begin{figure}[!t]
    \centering
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre3}
    \end{subfigure}
    \hfil
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre4}
    \end{subfigure}
    \caption{The left image shows the result after the genetic algorithm has executed. The obstacles in red have been selected to be modeled in the MILP problem. The dark grey shape is the convex allowed region generated by the genetic algortihm. Note how it does not overlap with any of the blue obstacles. The right image shows the final result. The trail of circles show the path of the vehicle up to the current time step, which is represented by the filled circles. The red and yellow colors depict the same information as in figure \ref{fig:obs}}\label{fig:pre-3-4}
\end{figure}

\subsection{Generating path segments}
\begin{algorithm}
\caption{Generating the segments}
\label{alg:segments}
\begin{algorithmic}[1]
\Function{GenSegments}{$path$, $events$}
\State $segments \leftarrow \{\}$
\State $catchUp \leftarrow true$
\State $lastEnd \leftarrow path(0)$
\For {$i \gets 0, |events| - 1 $}
\State $event \leftarrow events(i)$
\If{$catchUp$}
	%\State $segStart \leftarrow $ \Call{ExpandBackw}{$event.start$}
	%\State \Call{AddSegments}{$lastSegEnd$, $segStart$}
	%\State $lastSegEnd \leftarrow segStart$ 
	\State expand $event.start$ backwards
	\State add segments from $lastEnd$ to $event.start$
	\State $lastEnd \leftarrow event.start$
\EndIf
\State $nextEvent \leftarrow events(i+1)$
\If{$nextEvent.start$ is close to $event.end$}
	\State $mid \leftarrow$ middle between $event$ \& $nextEvent$
	\State add segment from $lastEnd$ to $mid$
	\State $lastEnd \leftarrow mid$
	\State $catchUp \leftarrow false$
\Else
	\State expand $event.end$ forwards
	\State add segment from $lastEnd$ to $event.end$
	\State $lastEnd \leftarrow event.end$
	\State $catchUp \leftarrow true$
\EndIf
\EndFor
\State add segments from $lastEnd$ to $path(|path|-1)$
\Return $segments$
\EndFunction
\end{algorithmic}
\end{algorithm}



%These corner events are in turn grown outwards to cover the approach and departure from the corner. How much depends on the maximum acceleration of the vehicle. As a rule of thumb: If the vehicle can come to a complete stop from its maximum speed before the corner, it can also successfully navigate that corner. When corners appear in quick succession, their expanded regions may overlap. In that case, the middle between those corners is chosen. Long, straight sections are also divided into smaller path segments.\\
%One of the main goals of segmenting the path is to reduce the amount of obstacles. This means that every segment has a set of obstacles associated with it, being the obstacles that need to be modeled in the optimization step. Not only the obstacle that ``causes'' the corner is important, but obstacles which are nearby are important as well. Obstacles on the outside of the corner also may play a role in how the vehicle approaches the corner. To find all potentially relevant obstacles, the convex hull of the (Theta*) path segment is calculated and scaled up slightly. Every obstacle which overlaps with this shape is considered an active obstacle for that path segment. The convex hull step ensures that all obstacles on the inside of the corner are included, while scaling it up will cover any restricting obstacle on the outside of the corner.

\subsubsection{Segment Generation Algorithm}
code \\
approachmargin \\
maxtime \\
step by step figures with explanation? 
\subsubsection{Segment data}
relevant points: pre path + stop point going in + stop point at finish. image with points clearly labeled \\
convex hull: quickhull. source + image for demo \\
note: only when about to be solved!
\subsection{Generating the active region for each segment}
One of the main goals of segmenting the path is to reduce the amount of obstacles. Every segment has a set of active obstacles associated with it, being the obstacles that need to be modeled for the solver. Not only the obstacle that ``causes'' the corner is important, but obstacles which are nearby are important as well. Obstacles on the outside of the corner also may play a role in how the vehicle approaches the corner. To find all potentially relevant obstacles, the convex hull of the (Theta*) path segment is calculated and scaled up slightly. Every obstacle which overlaps with this shape is considered an active obstacle for that path segment. The convex hull step ensures that all obstacles on the inside of the corner are included, while scaling it up will cover any restricting obstacle on the outside of the corner.\\
The inactive obstacles also need to be represented. To do this, a convex polygon is constructed around the path. This polygon may intersect with the active obstacles (since they will be represented separately), but may not intersect any other obstacle. The polygon is grown using a genetic algorithm. Genetic algorithms are inspired by natural selection in biology. A typical genetic algorithm consists of a population of individuals, a selection strategy and one or more operators to generate offspring. In each generation, the operators are applied on the population to produce offspring. These operators usually have a random element and are responsible for exploration of the search space. The selection strategy determines, often based on a fitness function, which individuals survive and form the population for the next generation. Selection is responsible for convergence towards fitter individuals, limiting how much of the search space is evaluated. \\

\subsubsection{Implementation of the genetic algorithm}
\begin{algorithm}
\caption{Genetic Algorithm}
\label{alg:ga}
\begin{algorithmic}[1]
\Function{GenActiveRegion}{$scenario$, $segment$}
\State $pop \leftarrow $ \Call{SeedPopulation}{}
\For {$i \gets 0, N_{gens} $}
\State $pop \leftarrow pop \cup $ \Call{Mutate}{$pop$}
\State \Call{Evaluate}{$pop$}
\State $pop \leftarrow $ \Call{Select}{$pop$}
\EndFor
\Return \Call{BestIndividual}{$pop$}
\EndFunction
\Function{Mutate}{$pop$}
\ForEach {$individual \in pop$}
\State add vertex with probability $p_{add}$
\State OR remove vertex with probability $p_{remove}$
\ForEach {$gene \in individual.chromosome$}
\State randomly move vertex by at most $\Delta_{nudge}$
\If{new polygon is legal}
\State update polygon
\Else
\State try again at most $N_{attempts}$ times
\EndIf
\EndFor
\EndFor
\Return \Call{BestIndividual}{$pop$}
\EndFunction
\end{algorithmic}
\end{algorithm}

Alg. \ref{alg:ga} shows our implementation. In our implementation, each individual in the population represents a single legal polygon. A legal polygon is convex, does not self-intersect, does not overlap with inactive obstacles and contains every node in the Theta* path for that specific segment. The latter requirement prevents the polygon from drifting off. Each individual has a single chromosome, and each chromosome has a varying number of genes. Each gene represents a vertex of the polygon.\\
The only operator is a mutator (line 4). Contrary to how mutators usually work, the mutation does not change the original individual. This means that the every individual can be mutated in every generation, since there is no risk of losing information. This mutator can add or remove vertices of the polygon by adding or removing genes (lines 12-13), but only if the amount of genes stays between $N_{genes,min}$ and $N_{genes,max}$. The mutator attempts to nudge every vertex/gene to a random position at most $\Delta_{nudge}$ away (line 15). If the resulting polygon is not legal, it retries at most $N_{attempts}$ times (line 16-19). \\
Tournament selection is used as the selector, with the fitness function being the surface area of the polygon (line 5-6). Fig. \ref{fig:pre-comp} Shows the active obstacles in yellow and red, as well as the polygon generated by the genetic algorithm in dark gray.\\


library \\
tournament selection \\
offspring generation: mutate only \\
initial population \\
chromosome/gene description \\
fitness function \\
validation \\
parameters \\
obstacle selection based on path length? \\


