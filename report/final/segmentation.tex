\section{Segmentation of the MILP problem}
\label{section:segment}
This section proposes a preprocessing algorithm to improve the scalability of MILP trajectory planning.\\ 
Assuming Hypothesis \ref{hyp:nonconvex} is true, a high degree of non-convexity around the trajectory causes slow solve times. There are two issues with this. The first issue is that the trajectory is the solution for the problem. If the solution is known, the problem does not need to be solved anymore. The second issue is that even if the optimal trajectory is known, the degree of non-convexity around that trajectory cannot be reduced by much since it already is the optimal trajectory. For instance, the Up/Down scenario in Figure \ref{fig:benchmarks-convex} cannot be made more convex without changing the original problem.\\
However, these issues can be resolved by relaxing the requirement of finding the optimal trajectory. The UAV operates in the real world, so a "good enough" trajectory will do. The MILP trajectory planning problem can be divided into many sub-problems, each of which solve a small part of the trajectory. By dividing the MILP problem into smaller sub-problems, the guarantee of optimality no longer holds. The optimal trajectory for each sub-problem will be found, but the combined trajectories may not be the optimal solution for the original problem. However, the degree of non-convexity can be limited in each sub-problem, which improves the scalability. \\
The non-convexity of a trajectory planning problem manifests itself as turns in the trajectory. Because of this, limiting the amount of turns in each sub-trajectory also limits the degree of non-convexity around the sub-trajectory. Limiting the amount of turns in each sub-problem is one of the goals for the preprocessing algorithm.\\
Before the algorithm can take turns into account when building the sub-problems, the turns in the trajectory need to be known. This trajectory is not known in advance, but this is not required. A faster path planning algorithm can be used to find a path from the start to the goal position. Unlike a trajectory, a path is not time-dependent and does not take the dynamics of the UAV into account. These simplifications make path planning algorithms typically much faster than trajectory planning algorithms. Despite the limitations of the path, the turns in the path do correspond to turns in the trajectory. However, it also means the trajectory may not be the fastest trajectory. Once again, optimality is sacrificed. \\
TODO: feasibility?
%\subsection{Introduction}
%The MILP model described in section \ref{section:modelingbasic} is sufficient to solve the trajectory planning problem for short flights with few obstacles. However, it scales poorly when the duration of the flight or the amount of obstacles is increased. Mixed-Integer programming belongs to the ``NP-Complete'' class of problems \cite{DBLP:conf/coco/Karp72}. This is a class of problems which is considered very hard to solve. As the amount of integer variables grows, the time needed to solve the problem increases exponentially. An integer variable is needed for every edge of every polygon, for every time step. By reducing both the amount of time steps needed and obstacles that need to be modeled, the execution time can be reduced dramatically. \\
%The key insight that allows my algorithm to scale well beyond what's usually possible is that the path trajectory not need to be solved all at once. If the trajectory planning problem can be split into many different subproblems, each subproblem becomes easier to solve. The solution for each subproblem is a small part of the final trajectory. By solving theses subproblems sequentially, the final trajectory can gradually be constructed. \\
%While diving the problem into subproblems does make things much easier to solve, it also has an important down side: Finding the fastest trajectory can no longer be guaranteed. Smaller subproblems make it easier to find a solution, but fundamentally the problem of finding the optimal trajectory is still just as hard. The necessary trade-off for better performance is that the optimal trajectory will likely not be found. Luckily, the optimal trajectory is often not required in navigation. A reasonably good trajectory will do.
%
%\subsubsection{The importance of convexity}
%While the worst case time needed to solve a MILP problem increases exponentially with the amount of integer variables, this is not the most useful way to measure the difficulty of a problem. Modern solvers are heavily optimized and are able to solve certain problems with many integer variables much faster than others. The key difference is the convexity of the solution space. Just like a circle is the solution space for ``all points a certain distance away from the center point'', the constraints used to model the trajectory planning problem form some geometric shape with a dimension for every variable. \\
%When only linear constraints with real values are used, the solution space will always be convex. It is this convexity that makes a standard linear program easy to solve. When integer variables are introduced, it is possible to construct solution spaces which are not convex. As the solution space becomes less and less convex, the problem becomes harder to solve. Integer variables can be seen as a tool which allows non-convex solution spaces to be modeled. When trying to improve the difficulty of a problem, the actual goal is making the problem more convex (or smaller, which always helps). Reducing the amount of integer variables is only a side effect. \\
%This insight is critical when determining how to divide the trajectory problem into smaller subproblems, and which obstacles are important for each subproblem.
\subsubsection{General Algorithm Outline}
\begin{algorithm}
\caption{General outline}
\label{alg:outline}
\begin{algorithmic}[1]
\State $T \leftarrow \{\}$ \Comment{The list of solved subtrajectories}
\State $path \leftarrow$ \Call{Theta*}{$scenario$}
\State $events \leftarrow$ \Call{FindTurnEvents}{$path$}
\State $segments \leftarrow$ \Call{GenSegments}{$path$, $events$}
\ForEach {$segment \in segments$}
\State \Call{UpdateStartState}{$segment$}
\State \Call{GenSafeRegion}{$scenario$, $segment$}
\State \Call{GenSubMILP}{$scenario$, $segment$}
\State $T \leftarrow T \cup \{$ \Call{SolveSubMILP}{} $\}$
\EndFor
\State $result \leftarrow $\Call{MergeTrajectories}{$T$}
\end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:outline} shows the general outline of the algorithm. It consists of two phases. The first phase gathers information about the trajectory planning problem. A Theta* path planning algorithm is used to find an initial path (line 2). From this initial path, turn events are generated (line 3). These turn events mark where the trajectory will have to turn. \\
The seconds stage builds and solves "segments". Each segment represents a single sub-trajectory. The segments contain the information needed to build the corresponding MILP sub-problem, which can in turn be solved by the solver. First, each segment is generated (line 3) from the turns found in the previous step. Before the MILP sub-problem can be generated and solved (line 8-9), a heuristic selects several obstacles to be modeled in the problem. A genetic algorithm generates a safe region which is allowed with those selected obstacles only (line 7). To ensure a seamless transition between two consecutive sub-trajectories, the starting state for the UAV in the MILP current segment is updated to match the final state of the UAV in the previous segment (line 6). Finally, the sub-trajectories are merged together to form the final trajectory (line 11).

%The algorithm I developed consists of two phases.\\
%In the first phase, information is gathered about the trajectory planning problem. The Theta* algorithm is used to construct an initial path from the start to the goal position. Unlike a trajectory, a path is not time-dependent and does not take dynamic properties into account. This makes a path much easier to calculate than a trajectory. While the Theta* path is not suitable to describe the movements of a UAV, it contains useful information about the trajectory we want to calculate. More specifically, the turns in the Theta* path are used to generate path segments. Each path segment contains the information needed to construct a MILP subproblem. \\
%In the second phase, each path segment considered sequentially. First, for all but the first segment,


\subsection{Finding the initial path}
The first step in Algorithm \ref{alg:outline} is finding the Theta* path (line 2). This path will be used to divide the trajectory planning problem into segments. The MILP-problem generated from each of those segments needs an intermediate goal to get the UAV closer to the final goal position. These intermediate goals will be determined by the Theta* path. \\
This path is not only useful to guide the trajectory towards the goal. It is also lets the algorithm determine where the turns will be in the trajectory.

\subsubsection{A*}
Theta* is a variant of the A* path planning algorithm. In A*, the world is represented as a graph. Each possible position is represented as a node, with edges between nodes if one position can be reached from the other. The distance between connected positions is represented as a weight or cost on each edge. \\
Planning a path consists of picking a start and goal node. The A* algorithm will traverse the edges between nodes, keeping track of which edges it traversed to reach a certain node. When the algorithm reaches the goal node, the nodes visited to reach that goal node are the path from the start node to the goal . \\
In this case, the world the UAV travels through is a continuous (2D) world. The graph for A* star is generated by overlaying a grid on the world. Nodes are placed at each intersection of the grid, as long as they are not inside obstacles. Each node is also connected to its neighbors by moving horizontally, vertically or diagonally along the grid. Figure \ref{fig:astar-grid} shows an example of this.
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{astar-grid}
\caption{An example of how a grid is used to build the graph for the path finding algorithm. Each point is a node on the graph. If two points are connected by a line, their nodes in the graph also are connected by an edge. Diagonal edges are not shown here for clarity.}
\label{figure:astar-grid}
\end{figure}

\subsubsection{Reason for Theta*}
A* finds the shortest path through the graph. However, this graph is only an approximate representation of the actual continuous world. An A* path will only travel along the edges of the graph. This means that the path can only travel horizontally, vertically and possibly diagonally. If the shortest path between two points is at another angle, the A* path will contain zig-zags or detours because it is limited to traveling along the grid. \\
Theta* solves this problem. It is nearly identical to A*, but it allows the path to travel at arbitrary angles. It still traverses the graph using the edges between nodes, but does not restrict the path to only following those edges.

\begin{figure}
\includegraphics[width=0.5\textwidth]{a_theta_star_comp3}
\caption{The red line shows a typical A* path, compared to the path found by Theta*. The gray rectangle is an obstacle.}
\label{figure:thetastarcompare}
\end{figure}


\subsubsection{Theta* implementation}
\begin{algorithm}
\caption{Theta* Implementation}
\label{alg:thetastar}
\begin{algorithmic}[1]
\Function{Theta*}{$scenario$}
	\State $g(v_{start}) \leftarrow 0$
	\State $parent(v_{start}) \leftarrow null$
	\State $queue \leftarrow \emptyset$
	\State $queue$.Insert($v_{start}$, $g(v_{start}) + h(v_{start})$)
	\State $expanded \leftarrow \emptyset$
	\While{$queue \neq \emptyset$}
		\State $s \leftarrow queue$.Pop()
		\If{$s = v_{goal}$}
			\Return $s$.GetPath()
		\EndIf
		\State $expanded \leftarrow expanded \cup \{s\}$
		\ForEach{$s' \in ~ $GenerateNeighbors($s$)}
			\If{$s' \notin expanded $}
%				\If{$s' \notin queue$}
%					\State{$g(s') \leftarrow \infty $}
%					\State{$parent(s') \leftarrow null $}
%				\EndIf
				\State{UpdateVertex($s$,$s'$)}
			\EndIf
		\EndFor
	\EndWhile
	\Return "no path found"
\EndFunction
\Function{UpdateVertex}{$s$,$s'$}
	\If{LineOfSight($parent(s)$,$s'$)}
		\State $s_{parent} \leftarrow parent(s)$
	\Else
		\State $s_{parent} \leftarrow s$	
	\EndIf
	\If{$g(s_{prev}) + c(s_{prev},s') < g(s')$}
		\State $g(s') \leftarrow g(s_{parent}) + c(s_{parent},s')$
		\State $parent(s') \leftarrow s_{parent}$
		\State $queue$.Insert($s'$,$g(s') + h(s')$)
	\EndIf
\EndFunction{}
\end{algorithmic}
\end{algorithm}
TODO: paraphrased! CITE!!
Algorithm \ref{alg:thetastar} shows how Theta* is implemented. It uses the following elements:
\begin{itemize}
\item the g-value $g(s)$ is the length of the shortest path between the start node and $s$.
\item a function $c(s,s')$ which returns the distance between node $s$ and $s'$.
\item a heuristic function $h(s)$, which approximates the path distance left before the goal position $s_{goal}$ is reached. The straight line distance between $s$ and the $s_{goal}$ is used, such that $h(s) = c(s,s_{goal})$. An admissible heuristic function must always be an underestimation of the actual path distance to the goal, which is ensured by using the straight line distance. 
\item a function $parent(s)$ which returns the node before $s$ in the path. When the parent of a node is $null$, it is either not part of the path or the first node of the path.
\item a priority queue $queue$. This is a queue of nodes to expand next. Each node $s$ is added with a value $x$ using the $queue.$Insert($s$,$x$) method. If $s$ is already in $queue$, its value is updated to $x$. The $queue$.Pop() method removes and returns the node $s$ with the lowest value $x$.
\item a set $expanded$ which contains all nodes which have already been expanded.
\item a function GenerateNeighbors($s$) which generates and returns the neighbors of node $s$. These are the neighboring positions on the grid around $s$
\end{itemize}
\paragraph{Initialization}
When the algorithm initializes, the g-value of the start node $v_{start}$ is set to zero and its parent is set to $null$ (line 2-3). The priority queue $queue$ is initialized, and $v_{start}$ is added to it with value $g(v_{start}) + h(v_{start})$. The value attached to a node $v$ in the priority queue is the shortest possible length of a path going from the start $v_{start}$ to the goal $v_{goal}$, while going through $v$. The g-value is the length of the path between $v_{start}$ and $v$, while $h(s)$ is an estimate of the length of the path between $v$ and $v_{goal}$.
\paragraph{Main loop}
$queue$.Pop() always removes the node with $s$ the lowest value (line 8). This means that as more nodes get added to $queue$, the algorithm will always explore the "most promising leads" first. If $s = v_{goal}$, the goal has been reached and the path is returned (line 9-11). Otherwise, $s$ is added to $expanded$ (line 12). This prevents $s$ from being added to $queue$ again. Line 13 generates every neighbor $s'$ of $s$ according to the grid and obstacles, as seen in Figure \ref{fig:astar-grid}, "expanding" node $s$. If the neighbor $s'$ has not been expanded yet, UpdateVertex($s$,$s'$) is called (line 14-16).
\paragraph{UpdateVertex}
So far, the algorithm is identical to A*. The only difference between A* and Theta* are lines 22-26. Line 22 checks if the parent of $s$, which is the node before $s$ in the path, can be connected in a straight line to $s'$. Going from $parent(s)$ to $s'$ directly is always shorter than going from $parent(s)$ to $s$ and from $s$ to $s'$ due to the triangle inequality. If $parent(s)$ and $s'$ are in line of sight, the path should be constructed from $parent(s)$ to $s'$, skipping $s$. Otherwise, the path goes through $s$, which is the behavior  of A*. The choice of which node should be parent of $s'$ is stored as $s_{parent}$\\
Line 27 checks if the path through $s_{parent}$ to $s'$ is the shortest path to $s'$ found so far. If this is not the case, a shorter path to $s'$ exists so the  path through $s_{parent}$ can safely be ignored. Otherwise, the g-value of $s'$ is updated to the length of the path to $s_{parent}$, $g(s_{parent})$ plus the distance between $s_{parent}$ and $s'$, $c(s_{parent},s')$ (line 28). The shortest path to $s'$ is updated by setting $parent(s')$ to $s_{parent}$ (line 29). Finally, $s'$ is added to $queue$ to be expanded further.
\subsubsection{Performance improvements}
By introducing the line of sight check, Theta* is considerably slower than A* in large worlds with many obstacles. The goal of this thesis is to improve scalability of trajectory planning to large and complex worlds, so the preprocessing phase must also scale well. \\
To help Theta* scale, the world is divided into rectangular sectors. When the world is first loaded, the algorithm determines in which sector(s) each obstacle is placed, creating an index mapping sectors to obstacles. \\
When the line of sight check is executed, the algorithm determines which sectors the line crosses. This is usually just one or two sectors. By using the index, only the obstacles in those sectors need to be considered for the line of sight check. This is much faster than having to check every obstacle in the entire world every time.



\subsection{Detecting corner events}
According to Hypothesis \ref{hyp:nonconvex}, the degree of non-convexity around the trajectory is responsible for the poor performance of MILP trajectory planning problem. This local degree of non-convexity around the trajectory is the amount of distinct convex shapes the trajectory needs to pass through to reach the goal position, such that every point in the trajectory lies within at least one shape. \\
Within a single convex shape, by definition, it is always possible to move in a straight line from one side of the shape to the other. As a consequence, if multiple convex shapes are needed, the trajectory needs to make a turn. If the turn is not needed, that implies the trajectory can go in a straight line, which means that only a single convex shape is needed. \\
Because of this, the turns in the trajectory and the degree of non-convexity are  directly related. Every turn in the trajectory is a manifestation of a transition between two or more convex shapes, and thus contributes to the degree of non-convexity of the entire trajectory. \\
Solving the trajectory in smaller segments reduces the degree of non-convexity in each segment, making them easier to solve. If Hypothesis \ref{hyp:nonconvex} is true, minimizing the amount of turns in each segment will improve performance even more. \\
While the Theta* path is only a rough approximation of the trajectory, it does have turns in roughly the same places as the trajectory will have. Finding those turns allows the algorithm build segments such that the amount of turns in each segment is minimal. \\
Because Theta* is used to generate the initial path, finding the turns is easy. When two nodes are in each other's line of sight, it is possible to construct a convex shape around those points. When they are not within line of sight, which is when Theta* keeps the previous node in the path, this is not possible. Using the same reasoning as above, the nodes in the Theta* path must always coincide with turns in both the Theta* path and the trajectory. \\
While every node in the Theta* path (except the start and goal) coincide with a turn, they can be close together. When two or more consecutive nodes turn in the same direction (clockwise or counter-clockwise) and are close enough together, they can be considered to represent a single turn. The algorithm groups those nodes together in a turn event. Each turn event contains one or more nodes. A turn event predicts the existence of a turn in the MILP trajectory based on the   Theta* path, bridging the gap between them.
%With an initial path generated, the next problem is dividing it into segments. Dividing the path into equal parts presents problems, because when solving each segment, the solver has no knowledge of what will happen in the next segment. This is especially problematic when the vehicle needs to make a tight corner. If the last segment ends right before the corner, it may not be possible to avoid a collision. Because of this, corners need to be taken into account when generating the segments. The right image in figure \ref{fig:pre-1-2} shows the transitions between segments as green circles.\\
%In Euclidian geometry, the shortest path between two points is always a straight line. When polygonal obstacles are introduced between those points, the shortest path will be composed of straight lines with turns at one or more vertices of the obstacles. The obstacle that causes the turn will always be on the inside of the corner. This shows why corners are important for another reason: They make the search space non-convex. For obstacles on the outside of the corner it is possible to constrain the search space so it is still convex, but this is not possible for obstacles on the inside of a corner.\\
%Because of these reasons, isolating the corners from the rest of the path is advantageous. With enough buffer before the corner, the vehicle is much more likely to be able to navigate the corner successfully. It also means that the computationally expensive parts of the path are as small as possible while still containing enough information for fast navigation through the corners.
%\\
%The reason for using Theta* becomes clear now. Every single node in the path generated by the algorithm is guaranteed to be either the start, goal or near a corner. A corner can have more than one node, so nodes which turn in the same direction and are close to each other are grouped together and considered part of the same corner. For each corner, a corner event is generated.

\subsubsection{Algorithm Implementation}
Algorithm \ref{alg:corners} processes the Theta* path to generate turn events. Two factors determine whether or not nodes are grouped together into events:
\begin{itemize}
\item The turn direction: a node $v$ in the path can either turn the path clockwise or counter-clockwise, as determined by TURNDIR($v$) Two nodes with a different turn direction cannot be in the same turn event
\item The maximum distance between two nodes in a turn event: Nodes which are too far from each other should not be merged. This distance $\Delta max$ is based on a turn tolerance parameter multiplied by the UAV's maximum acceleration distance (MAD). 
\end{itemize}



\paragraph{Maximum Acceleration Distance}
With $a_{max}$ and $v_{max}$ respectively the UAV's maximum acceleration and velocity, the time needed to reach the maximum velocity is $t_{max} = v_{max} / a_{max}$. The maximum acceleration distance in the distance traveled in that time, which is $t_{max}^2 / 2 = v_{max}^2 / 2a_{max}$. The $MAD$ is used in several places in the algorithm as an approximation of the distance in which the UAV can recover from a maneuver. In $1*MAD$, the UAV can accelerate to any velocity from zero, or it can stop from any velocity. In $2*MAD$, the UAV can transition from any velocity vector to any other velocity vector. It is an approximation of the distance at which the presence or absence of an event can influence the UAV. \\
In this case, the MAD is relevant because turns require the velocity vector of the UAV to change from before the turn to after the turn. If two nodes have a distance of more than $2*MAD$ between them, the turns at each node can be taken independently as distinct turns. TODO: fig! \\
\par
EXPLAIN ALGO!!!!!!!

\begin{algorithm}
\caption{Finding Turn Events}
\label{alg:corners}
\begin{algorithmic}[1]
\Function{FindTurnEvents}{$path$}
  \State $\Delta max \leftarrow$ max. acc. distance * turn tolerance
  \State $events \leftarrow \{\}$ \Comment{The list of turn events found so far}
  \State $i \leftarrow 1$ \Comment{Skip the start node, it can't be a turn}
  \While{$i < |path| - 1$ } \Comment{Skip the goal node}
  	\State $event \leftarrow \{ path(i) \}$ \Comment{Start new turn event}
  	\State $turnDir \leftarrow$ \Call{TurnDir}{$path(i)$} 
    	\State $i \leftarrow  i + 1$
    	\While{$i < |path| - 1$ }
    	\If{$||path(i-1) - path(i)|| > \Delta max$}
    		\Break \Comment{Node is too far from previous}
	\EndIf
	\If{\Call{TurnDir}{$path(i)} \neq turnDir$}
		\Break \Comment{Node turns in wrong direction}
	\EndIf
	\State $event \leftarrow event \cup \{ path(i) \}$\Comment{Add to event}
	\State $i \leftarrow  i + 1$
	
    	\EndWhile
    	
    	\State $events \leftarrow events \cup \{ event \}$
  \EndWhile
\Return $events$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{figure}[!t]
    \centering
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre1}
    \end{subfigure}
    \hfil
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre2}
    \end{subfigure}
    \caption{The left image shows the results after the Theta* algorithm has executed. The blue shapes are obstacles, while the gray line is the Theta* path. The right image shows the results after the path is segmented. Extra nodes have been added to the Theta* path, as marked by the green circles. These circles depict the transitions between segments.}\label{fig:pre-1-2}
\end{figure}

\begin{figure}[!t]
    \centering
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre3}
    \end{subfigure}
    \hfil
    \begin{subfigure}[t]{0.47\textwidth}
        \includegraphics[width=\textwidth]{img/pre4}
    \end{subfigure}
    \caption{The left image shows the result after the genetic algorithm has executed. The obstacles in red have been selected to be modeled in the MILP problem. The dark grey shape is the convex allowed region generated by the genetic algortihm. Note how it does not overlap with any of the blue obstacles. The right image shows the final result. The trail of circles show the path of the vehicle up to the current time step, which is represented by the filled circles. The red and yellow colors depict the same information as in figure \ref{fig:obs}}\label{fig:pre-3-4}
\end{figure}






\subsection{Generating path segments}
\begin{algorithm}
\caption{Generating the segments}
\label{alg:segments}
\begin{algorithmic}[1]
\Function{GenSegments}{$path$, $events$}
\State $segments \leftarrow \{\}$
\State $catchUp \leftarrow true$
\State $lastEnd \leftarrow path(0)$
\For {$i \gets 0, |events| - 1 $}
\State $event \leftarrow events(i)$
\If{$catchUp$}
	%\State $segStart \leftarrow $ \Call{ExpandBackw}{$event.start$}
	%\State \Call{AddSegments}{$lastSegEnd$, $segStart$}
	%\State $lastSegEnd \leftarrow segStart$ 
	\State expand $event.start$ backwards
	\State add segments from $lastEnd$ to $event.start$
	\State $lastEnd \leftarrow event.start$
\EndIf
\State $nextEvent \leftarrow events(i+1)$
\If{$nextEvent.start$ is close to $event.end$}
	\State $mid \leftarrow$ middle between $event$ \& $nextEvent$
	\State add segment from $lastEnd$ to $mid$
	\State $lastEnd \leftarrow mid$
	\State $catchUp \leftarrow false$
\Else
	\State expand $event.end$ forwards
	\State add segment from $lastEnd$ to $event.end$
	\State $lastEnd \leftarrow event.end$
	\State $catchUp \leftarrow true$
\EndIf
\EndFor
\State add segments from $lastEnd$ to $path(|path|-1)$
\Return $segments$
\EndFunction
\end{algorithmic}
\end{algorithm}



%These corner events are in turn grown outwards to cover the approach and departure from the corner. How much depends on the maximum acceleration of the vehicle. As a rule of thumb: If the vehicle can come to a complete stop from its maximum speed before the corner, it can also successfully navigate that corner. When corners appear in quick succession, their expanded regions may overlap. In that case, the middle between those corners is chosen. Long, straight sections are also divided into smaller path segments.\\
%One of the main goals of segmenting the path is to reduce the amount of obstacles. This means that every segment has a set of obstacles associated with it, being the obstacles that need to be modeled in the optimization step. Not only the obstacle that ``causes'' the corner is important, but obstacles which are nearby are important as well. Obstacles on the outside of the corner also may play a role in how the vehicle approaches the corner. To find all potentially relevant obstacles, the convex hull of the (Theta*) path segment is calculated and scaled up slightly. Every obstacle which overlaps with this shape is considered an active obstacle for that path segment. The convex hull step ensures that all obstacles on the inside of the corner are included, while scaling it up will cover any restricting obstacle on the outside of the corner.

\subsubsection{Segment Generation Algorithm}
code \\
approachmargin \\
maxtime \\
step by step figures with explanation? 
\subsubsection{Segment data}
relevant points: pre path + stop point going in + stop point at finish. image with points clearly labeled \\
convex hull: quickhull. source + image for demo \\
note: only when about to be solved!
\subsection{Generating the active region for each segment}
One of the main goals of segmenting the path is to reduce the amount of obstacles. Every segment has a set of active obstacles associated with it, being the obstacles that need to be modeled for the solver. Not only the obstacle that ``causes'' the corner is important, but obstacles which are nearby are important as well. Obstacles on the outside of the corner also may play a role in how the vehicle approaches the corner. To find all potentially relevant obstacles, the convex hull of the (Theta*) path segment is calculated and scaled up slightly. Every obstacle which overlaps with this shape is considered an active obstacle for that path segment. The convex hull step ensures that all obstacles on the inside of the corner are included, while scaling it up will cover any restricting obstacle on the outside of the corner.\\
The inactive obstacles also need to be represented. To do this, a convex polygon is constructed around the path. This polygon may intersect with the active obstacles (since they will be represented separately), but may not intersect any other obstacle. The polygon is grown using a genetic algorithm. Genetic algorithms are inspired by natural selection in biology. A typical genetic algorithm consists of a population of individuals, a selection strategy and one or more operators to generate offspring. In each generation, the operators are applied on the population to produce offspring. These operators usually have a random element and are responsible for exploration of the search space. The selection strategy determines, often based on a fitness function, which individuals survive and form the population for the next generation. Selection is responsible for convergence towards fitter individuals, limiting how much of the search space is evaluated. \\

\subsubsection{Implementation of the genetic algorithm}
\begin{algorithm}
\caption{Genetic Algorithm}
\label{alg:ga}
\begin{algorithmic}[1]
\Function{GenActiveRegion}{$scenario$, $segment$}
\State $pop \leftarrow $ \Call{SeedPopulation}{}
\For {$i \gets 0, N_{gens} $}
\State $pop \leftarrow pop \cup $ \Call{Mutate}{$pop$}
\State \Call{Evaluate}{$pop$}
\State $pop \leftarrow $ \Call{Select}{$pop$}
\EndFor
\Return \Call{BestIndividual}{$pop$}
\EndFunction
\Function{Mutate}{$pop$}
\ForEach {$individual \in pop$}
\State add vertex with probability $p_{add}$
\State OR remove vertex with probability $p_{remove}$
\ForEach {$gene \in individual.chromosome$}
\State randomly move vertex by at most $\Delta_{nudge}$
\If{new polygon is legal}
\State update polygon
\Else
\State try again at most $N_{attempts}$ times
\EndIf
\EndFor
\EndFor
\Return \Call{BestIndividual}{$pop$}
\EndFunction
\end{algorithmic}
\end{algorithm}

Alg. \ref{alg:ga} shows our implementation. In our implementation, each individual in the population represents a single legal polygon. A legal polygon is convex, does not self-intersect, does not overlap with inactive obstacles and contains every node in the Theta* path for that specific segment. The latter requirement prevents the polygon from drifting off. Each individual has a single chromosome, and each chromosome has a varying number of genes. Each gene represents a vertex of the polygon.\\
The only operator is a mutator (line 4). Contrary to how mutators usually work, the mutation does not change the original individual. This means that the every individual can be mutated in every generation, since there is no risk of losing information. This mutator can add or remove vertices of the polygon by adding or removing genes (lines 12-13), but only if the amount of genes stays between $N_{genes,min}$ and $N_{genes,max}$. The mutator attempts to nudge every vertex/gene to a random position at most $\Delta_{nudge}$ away (line 15). If the resulting polygon is not legal, it retries at most $N_{attempts}$ times (line 16-19). \\
Tournament selection is used as the selector, with the fitness function being the surface area of the polygon (line 5-6). Fig. \ref{fig:pre-comp} Shows the active obstacles in yellow and red, as well as the polygon generated by the genetic algorithm in dark gray.\\


library \\
tournament selection \\
offspring generation: mutate only \\
initial population \\
chromosome/gene description \\
fitness function \\
validation \\
parameters \\
obstacle selection based on path length? \\


