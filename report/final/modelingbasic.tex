\section{Modeling Path Planning as a MILP problem}
\label{section:modelingbasic}
\subsection{Introduction}
TODO: REWRITE
MILP is a form of mathematical programming, form of declarative programming. contrast with imperative programming: say what the solution looks like instead of how to get there. Mathematical programming: subset of declarative programming where problem is defined as mathematical problem. Solver computes result.\\
Big advantages: \\
- dont need to say how it is done, focus is on precisely modeling problem.\\
- flexible: can easily change rules: make problem more restrictive or relaxed, change the goal, etc ``just works''\\
- can be really fast thanks to work on solvers\\
\\
disadvatages:\\
- no free lunch (find reference): for anything more than very basic cases, solver cannot guarantee that a solution will be found any faster than random search\\
	--> cant rely on just the solver doing the work, problem needs to be stated in a way that guides solver in the right direction
	--> even when careful, as problem becomes more complex, solvers struggle\\
-  hard to understand: solver finds solution or not.
	-->Solution is optimal, but if it is not as expected it does not give any information why.
	-->when no solution: can show which constraint failed, but problem is not necessarily there. complex interplay between constraints is extremely hard to debug\\


\subsection{Terminology}
TODO: FILL OUT
variable
constraint
solution space
feasible region
solver (cplex)
convex

\subsection{Importance of integers and convexity}
TODO: REWRITE
linear programming one of the most simple forms of mathematical programming. Only linear functions allowed, all variables have a real domain. If feasible region exists: inherently convex. When a problem is convex, typically efficient solvers can be written (TODO: find source). This is the case for LP. LP problems can be solved reliably and quickly.
\\
Problem: only real variables is very limiting. Logical operators are impossible to model. Result is that not every problem can be modeled without integers. Adding integers seems like a minor change, but it no longer guarantees that the feasible region is convex. When the problem is no longer convex, it becomes intractible. An intractible problem is a problem for which we do not have a strategy that will on average find the solution faster than random guessing.
\\
Path planning when obstacles are present inherently needs integer variables and thus is an intractible problem. The goal of this thesis is to make this approach to path planning scalable. This will rely on two concepts://
- The solvers are on average not faster than random, but that's the average of all problems. We are only concerned with a very specific kind of problem. By being aware of how the solver works and simply experimenting with different representations, the problem can be solved much faster\\
- We can cheat. The problem can be greatly simplified and approximated. This means that the solution is no longer guaranteed to be optimal, but as long as it is good enough this is not a problem.\\


\subsection{Basic Path Planning MILP Model}

The path planning problem can be represented with discrete timesteps with a set of state variables for each epoch. The amount of timesteps determines the maximum amount of time the vehicle has in solution space to reach its goal. The actual movement of the vehicle is modeled by calculating the accelleration, velocity and position at each timestep based on the throttle (in each axis) and state variables from the previous time step.

\begin{figure}[h]
\begin{math}
time_0 = 0 \\
time_{t+1} = time_{t} + \Delta t,  \quad 0 \leq t < N \\ \\
\boldsymbol{pos}_0 = \boldsymbol{pos}_{start} \\
\boldsymbol{pos}_{t+1} = \boldsymbol{pos}_{t} + \Delta t * \boldsymbol{vel}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{vel}_0 =\boldsymbol{vel}_{start} \\
\boldsymbol{vel}_{t+1} =\boldsymbol{vel}_{t} + \Delta t * \boldsymbol{acc}_{t}  \quad 0 \leq t < N \\ \\
\boldsymbol{acc}_{t} = \boldsymbol{throttle}_{t} * \boldsymbol{acc}_{max}  \quad 0 \leq t \leq N \\
\end{math}
\end{figure}

The problem also needs a goal function to optimize. In this model, the goal is to minimize the time before a goal position is reached. Optionally, there is also a goal velocity that needs to be matched when the vehicle reaches the goal. Reaching the goal constraints causes a state transition from not being finished to being finished. Modeling state transitions directly can be error-prone, so Lamport's\cite{Lamport1989} state transition axiom method was used. In this simple model it is still possible to model the state transition directly, but the goal of the thesis is to provide a flexible and extensible approach.


\begin{figure}[h]
\begin{math}
minimize \quad N - \mathlarger{\sum}_{t=0}^{t \leq N} fin_t \\
fin_0 = 1 \\ 
fin_{t+1} = fin_t \vee cfin_{t+1},  \quad 0 \leq t < N \\ \\
cfin_{pos,t} =  \mathlarger{\mathlarger{\bigwedge_{i = 0}^{i < Dim(\boldsymbol{pos}_t)}}} |pos_{t,i} - pos_{goal, i}| < pos_{tol},  \quad 0 \leq t \leq N \\ \\ \\
cfin_t =  cfin_{pos,t} \quad 0 \leq t \leq N
\end{math}
\end{figure}


The most challenging part of the problem is modeling obstacles. Any obstacle between the vehicle and its goal will inherently make the search space non-convex. Because of this, integer variables are needed to model obstacles. The most common way to do this is to use the ``Big M'' method to model a polygon. The size of the vehicle needs to be taken into account. Assuming the polygon is convex and the vertices of the polygon are listed in counter-clockwise order, the following constraints model an obstacle:

\begin{figure}[h]
OBSTACLE CONSTRAINTS \\
\end{figure}

\subsection{Characteristics of the basic model}
Nothing new in basic model, motivate changes based on flaws in the model. demonstration with simple scenario (benchmark and spiral) where basic model already struggles. Approximate amount of integer variables needed, use as representation of nonconvexity of problem. \\
Also show issue with time allowed: Need to allocate way more time than is needed, making the problem even harder to solve. Limiting time makes problem faster to solve, but cannot know without prior information.\\
Demonstrate issue with corners. Corners make execution time go up even as amount of integer variables stays the same. If no corners are needed, feasible space stays more convex even though integer values are same. Nuance that integer variables are only apprixmation of non-convexity, convexity is real property that matters.\\
Conclude: need to reduce amount of obstacles, need to reduce timesteps, limit amount of corners at a time (so problem becomes more convex). Dividing problem into smaller pieces tackles all these goals.
